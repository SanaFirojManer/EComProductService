{\rtf1}
Controller --> Input --> DTO, Output --> DTO, Downstream(repo) -->Entity
layer at which dto to entity, or entity to dto conversion happens
conversion can be part of business logic

Repository --> Input --> Entity, Output --> Entity, DB saves Entity


Controller Inheritance or Composition:
If your ProductController inherits from or composes another controller (like a CartController),
 and the exception is thrown or handled in the superclass or composed controller,
 the advice from @ControllerAdvice may still be applied.

 ProductService
 ProductServiceImpl         FakeProductServiceImpl

 if@Autowired ProductService  -->single bean requred exception

 at controller
 @Autowired
 @Qulifier("productService")
 private ProductService productService;

 why we create base model??
 -->

 Cardinalities
 1:1   person adharCard
        1)Primary key of one table will write as fK in another table/class
        2)Mappng table


 1:M    1)fk relation
        2)mapping table


 M:1    1)fk relation
        2)mapping table



 M:M    Only mapping table

 default spring structure is mapping table for all

 Fech type
 Lazy  --> I will only first layer only category Just fech what is required any attribute out of that table will not fech.
 Eager --> all fechched in one time
 DTO and Entity

 1)controller   dto
    service     dto
       repo     entity
        db      entity

        actual conversion of dto --> entity at service layer conversion is part of business logic
        that mean code of mapper will invoke from service


 2)3rd part client
    controller          dto
        service         dto
            client      dto


 *Ideally all apis and client should have their own  two dtos 1)request 2)response
